# Environment Configuration
# Handles .env file creation and credential injection

container_commands:
  00-create-env:
    command: |
      # Ensure .env exists and is properly configured
      # This runs in /var/app/staging, will be moved to /var/app/current after deployment
      cd /var/app/staging
      
      # Check if .env exists in current (from previous deployment)
      if [ -f /var/app/current/.env ]; then
        cp /var/app/current/.env .env
        echo "Copied existing .env from current deployment"
      elif [ ! -f .env ]; then
        if [ -f .env.example ]; then
          cp .env.example .env
          echo "Created .env from .env.example"
        else
          # Create basic .env file with defaults
          cat > .env << 'ENVFILE'
      APP_NAME=Periscope
      APP_ENV=production
      APP_KEY=
      APP_DEBUG=false
      APP_URL=https://periscope.uniqlabs.co

      DB_CONNECTION=mysql
      DB_HOST=
      DB_PORT=3306
      DB_DATABASE=
      DB_USERNAME=
      DB_PASSWORD=

      QUEUE_CONNECTION=sqs
      SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/005483488708
      SQS_QUEUE=periscope-auth-queue

      MAIL_MAILER=ses
      MAIL_FROM_ADDRESS="do-not-reply@uniqlabs.co"
      MAIL_FROM_NAME="Periscope"

      AWS_ACCESS_KEY_ID=
      AWS_SECRET_ACCESS_KEY=
      AWS_DEFAULT_REGION=us-east-1
      ENVFILE
          echo "Created new .env file"
        fi
      fi
      
      # Update .env with RDS credentials if available (only if not already set)
      if [ ! -z "$RDS_HOSTNAME" ]; then
        if ! grep -q "^DB_HOST=" .env || grep -q "^DB_HOST=$" .env; then
          sed -i "s|^DB_HOST=.*|DB_HOST=$RDS_HOSTNAME|" .env || echo "DB_HOST=$RDS_HOSTNAME" >> .env
        fi
        sed -i "s|^DB_PORT=.*|DB_PORT=${RDS_PORT:-3306}|" .env || echo "DB_PORT=${RDS_PORT:-3306}" >> .env
        sed -i "s|^DB_DATABASE=.*|DB_DATABASE=$RDS_DB_NAME|" .env || echo "DB_DATABASE=$RDS_DB_NAME" >> .env
        sed -i "s|^DB_USERNAME=.*|DB_USERNAME=$RDS_USERNAME|" .env || echo "DB_USERNAME=$RDS_USERNAME" >> .env
        sed -i "s|^DB_PASSWORD=.*|DB_PASSWORD=$RDS_PASSWORD|" .env || echo "DB_PASSWORD=$RDS_PASSWORD" >> .env
      fi
      
      # Update AWS credentials if available (only if not already set)
      if [ ! -z "$AWS_ACCESS_KEY_ID" ]; then
        if ! grep -q "^AWS_ACCESS_KEY_ID=" .env || grep -q "^AWS_ACCESS_KEY_ID=$" .env; then
          sed -i "s|^AWS_ACCESS_KEY_ID=.*|AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID|" .env || echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> .env
        fi
        if ! grep -q "^AWS_SECRET_ACCESS_KEY=" .env || grep -q "^AWS_SECRET_ACCESS_KEY=$" .env; then
          sed -i "s|^AWS_SECRET_ACCESS_KEY=.*|AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY|" .env || echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> .env
        fi
        sed -i "s|^AWS_DEFAULT_REGION=.*|AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}|" .env || echo "AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}" >> .env
      fi
      
      # Update SQS settings if not already set
      if ! grep -q "^SQS_PREFIX=" .env; then
        echo "SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/005483488708" >> .env
      fi
      if ! grep -q "^SQS_QUEUE=" .env; then
        echo "SQS_QUEUE=periscope-auth-queue" >> .env
      fi

      # Override from EB Environment properties when set (per-environment APP_URL, FRONTEND_URL, SQS_QUEUE)
      if [ -n "$APP_URL" ]; then
        grep -q "^APP_URL=" .env && sed -i "s|^APP_URL=.*|APP_URL=$APP_URL|" .env || echo "APP_URL=$APP_URL" >> .env
      fi
      if [ -n "$FRONTEND_URL" ]; then
        grep -q "^FRONTEND_URL=" .env && sed -i "s|^FRONTEND_URL=.*|FRONTEND_URL=$FRONTEND_URL|" .env || echo "FRONTEND_URL=$FRONTEND_URL" >> .env
      fi
      if [ -n "$SQS_QUEUE" ]; then
        grep -q "^SQS_QUEUE=" .env && sed -i "s|^SQS_QUEUE=.*|SQS_QUEUE=$SQS_QUEUE|" .env || echo "SQS_QUEUE=$SQS_QUEUE" >> .env
      fi

      # Generate APP_KEY if it's empty
      if ! grep -q "^APP_KEY=base64:" .env; then
        php artisan key:generate --force --no-interaction || echo "APP_KEY generation failed, will be set later"
      fi
      
      # Set proper permissions (600 = owner read/write only, more secure)
      chmod 600 .env
      chown webapp:webapp .env
    leader_only: true
  01-setup-db:
    command: |
      # Set database connection from RDS environment variables if they exist
      if [ ! -z "$RDS_HOSTNAME" ]; then
        export DB_CONNECTION=mysql
        export DB_HOST=$RDS_HOSTNAME
        export DB_PORT=$RDS_PORT
        export DB_DATABASE=$RDS_DB_NAME
        export DB_USERNAME=$RDS_USERNAME
        export DB_PASSWORD=$RDS_PASSWORD
        echo "Database connection configured from RDS environment variables"
      else
        echo "No RDS_HOSTNAME found, using environment properties for DB connection"
      fi
    leader_only: true
