# Environment Configuration
# EB/EC2 instances can be recreated, so we create .env on every deploy (never rely on a
# manually uploaded .env). We merge .env.example (or fallback), RDS, and EB Environment
# Properties (Configuration â†’ Software, or option_settings in 00-env-defaults).
# Set APP_KEY and other secrets in EB; get-config writes them into .env.

container_commands:
  00-create-env:
    command: |
      # Create .env during deploy (persists across instance replacements)
      # Runs in /var/app/staging; after deploy it becomes /var/app/current
      cd /var/app/staging

      # Create .env from .env.example or fallback; EB get-config overlays follow
      if [ -f .env.example ]; then
        cp .env.example .env
        echo "Created .env from .env.example"
      else
        cat > .env << 'ENVFILE'
      APP_NAME=Periscope
      APP_ENV=production
      APP_KEY=
      APP_DEBUG=false
      APP_URL=https://periscope.uniqlabs.co

      DB_CONNECTION=mysql
      DB_HOST=
      DB_PORT=3306
      DB_DATABASE=
      DB_USERNAME=
      DB_PASSWORD=

      QUEUE_CONNECTION=sqs
      SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/005483488708
      SQS_QUEUE=periscope-auth-queue

      MAIL_MAILER=ses
      MAIL_FROM_ADDRESS="do-not-reply@uniqlabs.co"
      MAIL_FROM_NAME="Periscope"

      AWS_ACCESS_KEY_ID=
      AWS_SECRET_ACCESS_KEY=
      AWS_DEFAULT_REGION=us-east-1
      ENVFILE
        echo "Created new .env file"
      fi

      # Update .env with RDS credentials if available (only if not already set)
      if [ ! -z "$RDS_HOSTNAME" ]; then
        if ! grep -q "^DB_HOST=" .env || grep -q "^DB_HOST=$" .env; then
          sed -i "s|^DB_HOST=.*|DB_HOST=$RDS_HOSTNAME|" .env || echo "DB_HOST=$RDS_HOSTNAME" >> .env
        fi
        sed -i "s|^DB_PORT=.*|DB_PORT=${RDS_PORT:-3306}|" .env || echo "DB_PORT=${RDS_PORT:-3306}" >> .env
        sed -i "s|^DB_DATABASE=.*|DB_DATABASE=$RDS_DB_NAME|" .env || echo "DB_DATABASE=$RDS_DB_NAME" >> .env
        sed -i "s|^DB_USERNAME=.*|DB_USERNAME=$RDS_USERNAME|" .env || echo "DB_USERNAME=$RDS_USERNAME" >> .env
        sed -i "s|^DB_PASSWORD=.*|DB_PASSWORD=$RDS_PASSWORD|" .env || echo "DB_PASSWORD=$RDS_PASSWORD" >> .env
      fi
      
      # Update AWS credentials if available (only if not already set)
      if [ ! -z "$AWS_ACCESS_KEY_ID" ]; then
        if ! grep -q "^AWS_ACCESS_KEY_ID=" .env || grep -q "^AWS_ACCESS_KEY_ID=$" .env; then
          sed -i "s|^AWS_ACCESS_KEY_ID=.*|AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID|" .env || echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> .env
        fi
        if ! grep -q "^AWS_SECRET_ACCESS_KEY=" .env || grep -q "^AWS_SECRET_ACCESS_KEY=$" .env; then
          sed -i "s|^AWS_SECRET_ACCESS_KEY=.*|AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY|" .env || echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> .env
        fi
        sed -i "s|^AWS_DEFAULT_REGION=.*|AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}|" .env || echo "AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}" >> .env
      fi
      
      # Update SQS settings if not already set
      if ! grep -q "^SQS_PREFIX=" .env; then
        echo "SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/005483488708" >> .env
      fi
      if ! grep -q "^SQS_QUEUE=" .env; then
        echo "SQS_QUEUE=periscope-auth-queue" >> .env
      fi

      # Override from EB Environment properties (Software -> Environment properties).
      # EB does not export these to the shell during container_commands; use get-config.
      if [ -x /opt/elasticbeanstalk/bin/get-config ]; then
        for key in APP_KEY APP_ENV APP_URL FRONTEND_URL SQS_QUEUE AUTH_OTP_BYPASS_MAGIC AUTH_PHONE_VERIFICATION_BYPASS_MAGIC; do
          val=$(/opt/elasticbeanstalk/bin/get-config environment -k "$key" 2>/dev/null || true)
          if [ -n "$val" ]; then
            if grep -q "^${key}=" .env; then
              sed -i "s|^${key}=.*|${key}=${val}|" .env
            else
              echo "${key}=${val}" >> .env
            fi
          fi
        done
      fi

      # Generate APP_KEY if it's empty
      if ! grep -q "^APP_KEY=base64:" .env; then
        php artisan key:generate --force --no-interaction || echo "APP_KEY generation failed, will be set later"
      fi
      
      # Set proper permissions (600 = owner read/write only, more secure)
      chmod 600 .env
      chown webapp:webapp .env
  01-setup-db:
    command: |
      # Set database connection from RDS environment variables if they exist
      if [ ! -z "$RDS_HOSTNAME" ]; then
        export DB_CONNECTION=mysql
        export DB_HOST=$RDS_HOSTNAME
        export DB_PORT=$RDS_PORT
        export DB_DATABASE=$RDS_DB_NAME
        export DB_USERNAME=$RDS_USERNAME
        export DB_PASSWORD=$RDS_PASSWORD
        echo "Database connection configured from RDS environment variables"
      else
        echo "No RDS_HOSTNAME found, using environment properties for DB connection"
      fi
    leader_only: true
