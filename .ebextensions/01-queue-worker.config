option_settings:
  aws:elasticbeanstalk:application:environment:
    COMPOSER_HOME: /root
  aws:elasticbeanstalk:environment:process:default:
    HealthCheckPath: /api/health
    HealthCheckInterval: 30
    HealthCheckTimeout: 5
    HealthyThresholdCount: 3
    UnhealthyThresholdCount: 5

files:
  "/opt/elasticbeanstalk/tasks/taillogs.d/queue-worker.conf":
    mode: "000644"
    owner: root
    group: root
    content: |
      /var/app/current/storage/logs/laravel.log
      /var/app/current/storage/logs/queue-worker.log

  "/opt/elasticbeanstalk/hooks/appdeploy/post/99_start_queue_worker.sh":
    mode: "000755"
    owner: root
    group: root
    content: |
      #!/bin/bash
      set -euo pipefail
      . /opt/elasticbeanstalk/support/envvars
      
      # Ensure we're in the correct directory (current, not staging)
      cd /var/app/current
      if [ ! -f "artisan" ]; then
        echo "ERROR: artisan file not found in /var/app/current. Current directory: $(pwd)" >&2
        exit 1
      fi
      
      LOG_FILE="/var/app/current/storage/logs/queue-worker.log"
      
      # Ensure storage directory structure exists and is writable
      # This must be done before starting the worker to prevent path resolution issues
      mkdir -p storage/logs storage/framework/cache storage/framework/sessions storage/framework/views storage/app/public
      touch "$LOG_FILE"
      chmod -R 775 storage bootstrap/cache
      chown -R webapp:webapp storage bootstrap/cache
      
      echo "$(date): Starting queue worker..." >> "$LOG_FILE"
      
      # Stop any existing queue workers
      pkill -f "queue:work sqs" || true
      sleep 2
      
      # Start queue worker in background as webapp user
      # Use sh -c to ensure redirection happens in webapp context
      echo "$(date): Starting queue worker process..." >> "$LOG_FILE"
      sudo -u webapp sh -c "cd /var/app/current && nohup php artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600 >> $LOG_FILE 2>&1 &"
      sleep 1
      WORKER_PID=$(pgrep -f "queue:work sqs" | head -n 1)
      
      # Wait a moment and verify the process is running
      sleep 3
      if [ ! -z "$WORKER_PID" ] && ps -p $WORKER_PID > /dev/null 2>&1; then
        echo "$(date): SUCCESS: Queue worker started (PID: $WORKER_PID)" >> "$LOG_FILE"
      elif pgrep -f "queue:work sqs" > /dev/null 2>&1; then
        WORKER_PID=$(pgrep -f "queue:work sqs" | head -n 1)
        echo "$(date): SUCCESS: Queue worker is running (PID: $WORKER_PID)" >> "$LOG_FILE"
      else
        echo "$(date): ERROR: Queue worker failed to start or crashed immediately." >> "$LOG_FILE"
        echo "$(date): Check the log above for SQS connection errors or IAM permission issues." >> "$LOG_FILE"
        echo "$(date): Ensure the EC2 instance role has AmazonSQSFullAccess policy attached." >> "$LOG_FILE"
        # Don't exit 1 here - allow deployment to continue, but log the error
      fi

container_commands:
  00-create-env:
    command: |
      # Ensure .env exists and is properly configured
      # This runs in /var/app/staging, will be moved to /var/app/current after deployment
      cd /var/app/staging
      
      # Check if .env exists in current (from previous deployment)
      if [ -f /var/app/current/.env ]; then
        cp /var/app/current/.env .env
        echo "Copied existing .env from current deployment"
      elif [ ! -f .env ]; then
        if [ -f .env.example ]; then
          cp .env.example .env
          echo "Created .env from .env.example"
        else
          # Create basic .env file with defaults
          cat > .env << 'ENVFILE'
      APP_NAME=Periscope
      APP_ENV=production
      APP_KEY=
      APP_DEBUG=false
      APP_URL=https://periscope.uniqlabs.co

      DB_CONNECTION=mysql
      DB_HOST=
      DB_PORT=3306
      DB_DATABASE=
      DB_USERNAME=
      DB_PASSWORD=

      QUEUE_CONNECTION=sqs
      SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/005483488708
      SQS_QUEUE=periscope-auth-queue

      MAIL_MAILER=ses
      MAIL_FROM_ADDRESS="do-not-reply@uniqlabs.co"
      MAIL_FROM_NAME="Periscope"

      AWS_ACCESS_KEY_ID=
      AWS_SECRET_ACCESS_KEY=
      AWS_DEFAULT_REGION=us-east-1
      ENVFILE
          echo "Created new .env file"
        fi
      fi
      
      # Update .env with RDS credentials if available (only if not already set)
      if [ ! -z "$RDS_HOSTNAME" ]; then
        if ! grep -q "^DB_HOST=" .env || grep -q "^DB_HOST=$" .env; then
          sed -i "s|^DB_HOST=.*|DB_HOST=$RDS_HOSTNAME|" .env || echo "DB_HOST=$RDS_HOSTNAME" >> .env
        fi
        sed -i "s|^DB_PORT=.*|DB_PORT=${RDS_PORT:-3306}|" .env || echo "DB_PORT=${RDS_PORT:-3306}" >> .env
        sed -i "s|^DB_DATABASE=.*|DB_DATABASE=$RDS_DB_NAME|" .env || echo "DB_DATABASE=$RDS_DB_NAME" >> .env
        sed -i "s|^DB_USERNAME=.*|DB_USERNAME=$RDS_USERNAME|" .env || echo "DB_USERNAME=$RDS_USERNAME" >> .env
        sed -i "s|^DB_PASSWORD=.*|DB_PASSWORD=$RDS_PASSWORD|" .env || echo "DB_PASSWORD=$RDS_PASSWORD" >> .env
      fi
      
      # Update AWS credentials if available (only if not already set)
      if [ ! -z "$AWS_ACCESS_KEY_ID" ]; then
        if ! grep -q "^AWS_ACCESS_KEY_ID=" .env || grep -q "^AWS_ACCESS_KEY_ID=$" .env; then
          sed -i "s|^AWS_ACCESS_KEY_ID=.*|AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID|" .env || echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> .env
        fi
        if ! grep -q "^AWS_SECRET_ACCESS_KEY=" .env || grep -q "^AWS_SECRET_ACCESS_KEY=$" .env; then
          sed -i "s|^AWS_SECRET_ACCESS_KEY=.*|AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY|" .env || echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> .env
        fi
        sed -i "s|^AWS_DEFAULT_REGION=.*|AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}|" .env || echo "AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}" >> .env
      fi
      
      # Update SQS settings if not already set
      if ! grep -q "^SQS_PREFIX=" .env; then
        echo "SQS_PREFIX=https://sqs.us-east-1.amazonaws.com/005483488708" >> .env
      fi
      if ! grep -q "^SQS_QUEUE=" .env; then
        echo "SQS_QUEUE=periscope-auth-queue" >> .env
      fi
      
      # Generate APP_KEY if it's empty
      if ! grep -q "^APP_KEY=base64:" .env; then
        php artisan key:generate --force --no-interaction || echo "APP_KEY generation failed, will be set later"
      fi
      
      # Set proper permissions
      chmod 644 .env
      chown webapp:webapp .env
    leader_only: true
  01-ensure-document-root:
    command: |
      # Verify Laravel structure exists in staging
      # EB will create /var/www/html symlink to /var/app/current during FlipApplication
      if [ ! -f /var/app/staging/public/index.php ]; then
        echo "ERROR: Laravel index.php not found in staging" >&2
        exit 1
      fi
    leader_only: false
  02-set-permissions:
    command: |
      # Set proper permissions for Laravel storage and cache directories
      # Ensure all required storage directories exist
      mkdir -p storage/logs storage/framework/cache storage/framework/sessions storage/framework/views storage/app/public
      chmod -R 775 storage bootstrap/cache || true
      chown -R webapp:webapp storage bootstrap/cache || true
      # Ensure log files exist with correct permissions
      touch storage/logs/laravel.log storage/logs/queue-worker.log || true
      chmod 664 storage/logs/*.log || true
      chown webapp:webapp storage/logs/*.log || true
    leader_only: true
  03-setup-db:
    command: |
      # Set database connection from RDS environment variables if they exist
      if [ ! -z "$RDS_HOSTNAME" ]; then
        export DB_CONNECTION=mysql
        export DB_HOST=$RDS_HOSTNAME
        export DB_PORT=$RDS_PORT
        export DB_DATABASE=$RDS_DB_NAME
        export DB_USERNAME=$RDS_USERNAME
        export DB_PASSWORD=$RDS_PASSWORD
        echo "Database connection configured from RDS environment variables"
      else
        echo "No RDS_HOSTNAME found, using environment properties for DB connection"
      fi
    leader_only: true
  04-clear-cache:
    command: "php artisan config:clear && php artisan route:clear || true"
    leader_only: true
  05-migrate:
    command: "php artisan migrate --force || echo 'Migration failed, continuing...'"
    leader_only: true
  06-optimize:
    command: |
      php artisan config:cache || echo 'Config cache failed'
      # Don't cache routes - let them load dynamically to ensure package routes are included
      # php artisan route:cache || echo 'Route cache failed'
      # Note: view:cache removed - API-only app, no views directory needed
    leader_only: true
